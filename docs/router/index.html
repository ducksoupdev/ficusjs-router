<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <base href="/">
  <meta name="description" content="Lightweight standalone client-side router that supports history and hash routing plus web components">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>FicusJS router documentation - Router</title>
  <link rel="stylesheet" href="css/doc.css">
  <link rel="apple-touch-icon" sizes="57x57" href="img/favicons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="img/favicons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="img/favicons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="img/favicons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="img/favicons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="img/favicons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="img/favicons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="img/favicons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="img/favicons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="img/favicons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="img/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="img/favicons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="img/favicons/favicon-16x16.png">
  <link rel="manifest" href="manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="img/favicons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
</head>
<body>
<svg style="position:absolute;height:0;width:0;">
  <symbol id="icon_home" viewBox="0 0 32 32">
    <g>
      <path d="M 16 2.59375 L 15.28125 3.28125 L 2.28125 16.28125 L 3.71875 17.71875 L 5 16.4375 L 5 28 L 14 28 L 14 18 L 18 18 L 18 28 L 27 28 L 27 16.4375 L 28.28125 17.71875 L 29.71875 16.28125 L 16.71875 3.28125 Z M 16 5.4375 L 25 14.4375 L 25 26 L 20 26 L 20 16 L 12 16 L 12 26 L 7 26 L 7 14.4375 Z "></path>
    </g>
  </symbol>
  <symbol id="icon_github" viewBox="0 0 32 32">
    <g>
      <path d="M 16 4 C 9.371094 4 4 9.371094 4 16 C 4 21.300781 7.4375 25.800781 12.207031 27.386719 C 12.808594 27.496094 13.027344 27.128906 13.027344 26.808594 C 13.027344 26.523438 13.015625 25.769531 13.011719 24.769531 C 9.671875 25.492188 8.96875 23.160156 8.96875 23.160156 C 8.421875 21.773438 7.636719 21.402344 7.636719 21.402344 C 6.546875 20.660156 7.71875 20.675781 7.71875 20.675781 C 8.921875 20.761719 9.554688 21.910156 9.554688 21.910156 C 10.625 23.746094 12.363281 23.214844 13.046875 22.910156 C 13.15625 22.132813 13.46875 21.605469 13.808594 21.304688 C 11.144531 21.003906 8.34375 19.972656 8.34375 15.375 C 8.34375 14.0625 8.8125 12.992188 9.578125 12.152344 C 9.457031 11.851563 9.042969 10.628906 9.695313 8.976563 C 9.695313 8.976563 10.703125 8.65625 12.996094 10.207031 C 13.953125 9.941406 14.980469 9.808594 16 9.804688 C 17.019531 9.808594 18.046875 9.941406 19.003906 10.207031 C 21.296875 8.65625 22.300781 8.976563 22.300781 8.976563 C 22.957031 10.628906 22.546875 11.851563 22.421875 12.152344 C 23.191406 12.992188 23.652344 14.0625 23.652344 15.375 C 23.652344 19.984375 20.847656 20.996094 18.175781 21.296875 C 18.605469 21.664063 18.988281 22.398438 18.988281 23.515625 C 18.988281 25.121094 18.976563 26.414063 18.976563 26.808594 C 18.976563 27.128906 19.191406 27.503906 19.800781 27.386719 C 24.566406 25.796875 28 21.300781 28 16 C 28 9.371094 22.628906 4 16 4 Z "></path>
    </g>
  </symbol>
</svg>
<div class="doc__bg"></div>
<nav class="header">
  <div class="wrapper">
    <div class="logo">FicusJS router <span class="logo__thin">Doc</span></div>
    <ul class="menu">
      <li class="menu__item toggle"><span></span></li>
      <li class="menu__item"><a href="https://github.com/ducksoupdev/ficusjs-router" target="_blank" rel="noopener noreferrer" class="link link--dark"><svg class="icon"><use xlink:href="#icon_github" /></svg> Github</a></li>
      <li class="menu__item"><a href="index.html" class="link link--dark"><svg class="icon"><use xlink:href="#icon_home" /></svg> Home</a></li>
    </ul>
  </div>
</nav>
<div class="wrapper">
  <div class="wrapper__content">
    <aside class="doc__nav">
      <ul>
        <li class=""><a href="docs/getting-started" class="doc__nav-item">Getting started</a></li>
        <li class=""><a href="docs/installation" class="doc__nav-item">Installation</a></li>
        <li class=""><a href="docs/features" class="doc__nav-item">Features</a></li>
        <li class=""><a href="docs/router" class="doc__nav-item">Router</a></li>
        <li class=""><a href="docs/browser-support" class="doc__nav-item">Browser support</a></li>
        <li class=""><a href="docs/going-build-less" class="doc__nav-item">Going build-less</a></li>
        <li class=""><a href="https://github.com/ducksoupdev/ficusjs-router/blob/master/CHANGELOG.md" target="_blank" rel="noopener noreferrer" class="doc__nav-item">Changelog</a></li>
        <li class=""><a href="docs/ficusjs" class="doc__nav-item">FicusJS</a></li>
      </ul>    </aside>
    <article class="doc__content">
      <h1>Router</h1>
<p>For multiple page applications, this simple client-side router is responsible for traversing a list of routes, finding the first matching route by string path, rendering any HTML returned from that route's action method into an outlet within the application.</p>
<p><strong>The router is a singleton - this ensures only one router instance exists as it controls page navigation.</strong></p>
<h2>Example</h2>
<p>Import the router creator function into your Javascript main file:</p>
<p><strong>main.js</strong></p>
<pre><code class="language-js">// import the createRouter function
import { createRouter } from 'https://unpkg.com/ficusjs-router?module'

// create list of routes
const routes = [
  { path: '/one', component: 'page-one' },
  { path: '/two', component: 'page-two' }
]

// Create a new router instance using the element selector as the router outlet
const router = createRouter(routes, '#router-outlet')
</code></pre>
<h2><code>createRouter</code> function</h2>
<p>Create your router instance using <code>createRouter</code> passing an array of routes and an element selector as the router outlet:</p>
<pre><code class="language-js">// create list of routes
const routes = [
  // routes defined here
]

const router = createRouter(routes, '#router-outlet')
</code></pre>
<p>When using the <code>createRouter</code> function, the following arguments can be passed:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>routes</code></td>
<td><code>Array</code></td>
<td>yes</td>
<td>An array of routes</td>
</tr>
<tr>
<td><code>rootOutletSelector</code></td>
<td><code>String</code></td>
<td>yes</td>
<td>A CSS selector for the main router outlet</td>
</tr>
<tr>
<td><code>options</code></td>
<td><code>Object</code></td>
<td></td>
<td>An optional set of options. See <a href="#options">options</a></td>
</tr>
</tbody>
</table>
<h2><code>getRouter</code> function</h2>
<p>The <code>getRouter</code> function is a quick way to retrieve the router instance.</p>
<pre><code class="language-js">// import the function
import { getRouter } from 'https://unpkg.com/ficusjs?module'

// use it within a component
createComponent('my-page-component', {
  navigateTo (url) {
    getRouter().push(url)
  }
})
</code></pre>
<h2>Routes</h2>
<p>Each route is a plain JavaScript object having <code>path</code> and either <code>component</code> or <code>action</code> properties.</p>
<p>A route <code>component</code> is a tag string for a component. For example; <code>my-page-component</code>.</p>
<pre><code class="language-js">{ path: '/one', component: 'page-one' }
</code></pre>
<p>A route <code>action</code> must be a function that returns a string for a component or a <code>Promise</code> that resolves a string for a component.
The string can contain props that are passed to the component. For example:</p>
<pre><code class="language-js">// render the page component with tag &lt;page-one&gt;
{ path: '/one', action: () =&gt; 'page-one' }
{ path: '/one', action: () =&gt; '&lt;page-one&gt;&lt;/page-one&gt;' } // same as above

// use the route params to render the component with props
{ path: '/one', action: (context, params) =&gt; `&lt;page-one title=&quot;${params.title}&quot; user=&quot;${context.user}&quot;&gt;&lt;/page-one&gt;` }
</code></pre>
<p>The <code>action</code> function receives <code>context</code> and <code>params</code> arguments when the route matches, and the action function invoked:</p>
<pre><code class="language-js">const routes = [
  { path: '/one', action: (context, params) =&gt; `&lt;page-one title=${params.title} user=${context.user}&gt;&lt;/page-one&gt;` }
]
</code></pre>
<ul>
<li><code>context</code> is an object with any data you want to pass to an action (see <a href="#options">Options</a> below)</li>
<li><code>params</code> is a key/value object containing URL and query string parameters matched for the route</li>
</ul>
<p>You can define an action using different ES6 flavours:</p>
<pre><code class="language-js">{
  path: '/',
  action: () =&gt; 'home-page' // inline fat-arrow function
}
{
  path: '/one',
  action () { // shortcut function declaration
    return 'page-one'
  }
}
</code></pre>
<h3>Adding routes dynamically</h3>
<p>Dynamically add more routes to the router using the <code>addRoutes</code> method.
The argument must be an <code>Array</code> using the same route format.</p>
<pre><code class="language-js">// create list of routes
const routes = [
  { path: '/one', component: 'page-one' },
  { path: '/two', component: 'page-two' }
]

const router = createRouter(routes, '#router-outlet')

// some time later
router.addRoutes([
  { path: '/three', component: 'page-three' },
  { path: '/four', action: () =&gt; `&lt;page-four show-menu=&quot;true&quot;&gt;&lt;/page-four&gt;` }
])
</code></pre>
<h3>Nested routes</h3>
<p>Each route may have an optional <code>children: [ ... ]</code> property containing the list of child routes:</p>
<pre><code class="language-js">const routes = [
  {
    path: '/admin',
    children: [
      {
        path: '',                        // www.example.com/admin
        component: 'admin-page'
      },
      {
        path: '/users',
        children: [
          {
            path: '',                    // www.example.com/admin/users
            component: 'user-list-page'
          },
          {
            path: '/:username',          // www.example.com/admin/users/john
            action: (context, { username }) =&gt; `&lt;user-profile-page username=&quot;${username}&quot;&gt;&lt;/user-profile-page&gt;`
          }
        ]
      }
    ]
  }
]
</code></pre>
<h2>Options</h2>
<p>You can pass an <code>options</code> object to the <code>createRouter</code> function to provide additional router configuration and context.</p>
<p>You can provide the following options:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Required</th>
<th>Default</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mode</code></td>
<td></td>
<td><code>history</code></td>
<td><code>string</code></td>
<td>The type of URL routing to use - <code>history</code> or <code>hash</code>. The default is <code>history</code> which requires a back-end to serve the application. A <code>hash</code> router uses hashes in the URL to route and doesn't require a server back-end</td>
</tr>
<tr>
<td><code>autoStart</code></td>
<td></td>
<td><code>true</code></td>
<td><code>boolean</code></td>
<td>Indicate if the router should auto-start. The default is <code>true</code>. If <code>false</code> is set, the <code>start()</code> method must be called to start the router</td>
</tr>
<tr>
<td><code>changeHistoryState</code></td>
<td></td>
<td><code>true</code></td>
<td><code>boolean</code></td>
<td>Indicate if the router should change the browser session history stack using <code>window.history.replaceState</code> and <code>window.history.pushState</code>. The default is <code>true</code></td>
</tr>
<tr>
<td><code>warnOnMissingOutlets</code></td>
<td></td>
<td><code>false</code></td>
<td><code>boolean</code></td>
<td>Indicate if the router should log a <code>console.warn</code> if a named outlet cannot be found. The default is <code>false</code></td>
</tr>
<tr>
<td><code>context</code></td>
<td></td>
<td></td>
<td><code>object</code></td>
<td><code>context</code> is an object with any data which you want to pass to <code>resolveRoute</code> function or an <code>action</code> function for a matched route</td>
</tr>
<tr>
<td><code>resolveRoute</code></td>
<td></td>
<td></td>
<td><code>function</code></td>
<td><code>resolveRoute</code> is a function for any custom route handling logic. For example you can define this option to work with routes in declarative manner. To render a route, this function must return either an HTML template or a <code>Promise</code> that resolves an HTML template. If <code>undefined</code> is returned, the router will attempt to match a route and call the <code>action</code> function if one is found</td>
</tr>
<tr>
<td><code>errorHandler</code></td>
<td></td>
<td></td>
<td><code>function</code></td>
<td><code>errorHandler</code> is a function for global error handling. Called with <code>error</code> and <code>context</code> arguments every time the route is not found or throws an error. This must return either an HTML template or a <code>Promise</code> that resolves an HTML template to be rendered when an error occurs</td>
</tr>
</tbody>
</table>
<p>Pass the <code>options</code> object to the <code>createRouter</code> function:</p>
<pre><code class="language-js">const routes = [
  { path: '', action: (context) =&gt; `&lt;home-page user=${context.user}&gt;&lt;/home-page&gt;` },
  { path: '/one', action: (context) =&gt; `&lt;page-one title=${context.params.title}&gt;&lt;/page-one&gt;` },
  { path: '/two', action: (context, params) =&gt; `&lt;page-two title=${params.title}&gt;&lt;/page-two&gt;` }
]

function logErrorAndRender (error) {
  return new Promise((resolve, reject) =&gt; {
    window.fetch('/error-logger', {
      method: 'POST',
      data: JSON.stringify(error),
      headers: {
        'Content-type': 'application/json'
      }
    })
    .then(() =&gt; resolve('page-error'))
    .catch(e =&gt; resolve(`&lt;page-error logger-error=${e.message}&gt;&lt;/page-error&gt;`))
  })
}

const options = {
  context: { user: null },
  resolveRoute (context, params) {
    if (typeof context.route.action === 'function') {
      return context.route.action(context, params)
    }
    return undefined
  },
  errorHandler (error, context) {
    console.error(error)
    console.info(context)
    return error.status === 404
      ? 'page-not-found'
      : logErrorAndRender(error)
  }
}

const router = createRouter(routes, '#router-outlet', options)
</code></pre>
<h3>Setting options</h3>
<p>You can set options at any time using the <code>setOptions</code> method on the router instance.</p>
<p>For example, this allows you to use a store as part of the router options after the store and router instances have been created.</p>
<pre><code class="language-js">const router = createRouter(routes, '#router-outlet')
const store = getStore('an-example-store')

// some time later
router.setOptions({
  ...router.options, // get the existing options from the router
  resolveRoute (context, params) {
    if (context.path === '/logout') {
      store.dispatch('setUserLoggedIn', false)
      return { redirect: '/' }
    }
  },
  errorHandler (error, context) {
    console.error(error)
    console.info(context)
    return error.status === 404
      ? 'page-not-found'
      : logErrorAndRender(error)
  }
})
</code></pre>
<h3>Modes</h3>
<p>There are two modes of routing available - <code>history</code> and <code>hash</code>.</p>
<h4>History routing</h4>
<p>A router that uses the HTML5 history API (<code>pushState</code>, <code>replaceState</code> and the <code>popstate</code> event) to keep your UI in sync with the URL.</p>
<h4>Hash routing</h4>
<p>A router that uses the hash portion of the URL (i.e. <code>window.location.hash</code>) to keep your UI in sync with the URL.</p>
<h3>Starting programmatically</h3>
<p>By default, the router will auto-start. This adds a listener to the History API to handle URL changes.</p>
<p>If you want to programmatically start the router you can call the <code>start()</code> method on the router instance.
You can optionally pass a location object or string path to the start method too for that route to be rendered.</p>
<pre><code class="language-js">// create a router but do not auto-start
const router = createRouter(routes, '#router-outlet', { autoStart: false })

// some time later
router.start()

// you can pass a location object or string path to the start method too for that route to be rendered
router.start('/home')
</code></pre>
<h2>URL Parameters</h2>
<p><strong>Named route parameters</strong> are captured and added to <code>context.params</code>.</p>
<pre><code class="language-js">const routes = [
  { path: '/hello/:username', action: (context) =&gt; `&lt;hello-page username=&quot;${context.params.username}&quot;&gt;&lt;/hello-page&gt;` }
]

const router = createRouter(routes, '#router-outlet')
</code></pre>
<p>Alternatively, captured parameters can be accessed via the second argument
to an action method like so:</p>
<pre><code class="language-js">const routes = [
  { path: '/hello/:username', action: (context, { username }) =&gt; `&lt;hello-page username=&quot;${username}&quot;&gt;&lt;/hello-page&gt;` }
]

const router = createRouter(routes, '#router-outlet')
</code></pre>
<p>Query string and hash parameters will be added to <code>context.params</code> for convenience.</p>
<h2>Context</h2>
<p>In addition to a URL path string, any arbitrary data can be passed to a route action method.</p>
<pre><code class="language-js">const routes = [
  { path: '/hello', action: (context) =&gt; `&lt;hello-page user=&quot;${context.user}&quot;&gt;&lt;/hello-page&gt;` }
]
const options = {
  context: { user: 'admin' }
}

const router = createRouter(routes, '#router-outlet', options)
</code></pre>
<p>Router always adds the following parameters to the <code>context</code> object
before passing it to the <code>resolveRoute</code> function:</p>
<ul>
<li><code>router</code> - Current router instance</li>
<li><code>route</code> - Matched route object</li>
<li><code>path</code> - Matched path</li>
<li><code>params</code> - Matched path and query string params, see <a href="#url-parameters">URL Parameters</a> section above for details</li>
</ul>
<h2>Async Routes</h2>
<p>The router works great with asynchronous functions out of the box:</p>
<pre><code class="language-js">const routes = [
  {
    path: '/hello/:username',
    async action({ params }) {
      const resp = await window.fetch(`/api/users/${params.username}`)
      const user = await resp.json()
      if (user) return `&lt;hello-page user=&quot;${user.displayName}&quot;&gt;&lt;/hello-page&gt;`
      return 'hello-page'
    },
  }
]

const router = createRouter(routes, '#router-outlet')
</code></pre>
<p>Alternatively, stick to Promises:</p>
<pre><code class="language-js">const routes = [
  {
    path: '/hello/:username',
    action ({ params }) {
      return window.fetch(`/api/users/${params.username}`)
        .then(resp =&gt; resp.json())
        .then(user =&gt; user ? `&lt;hello-page user=&quot;${user.displayName}&quot;&gt;&lt;/hello-page&gt;` : 'hello-page')
    }
  }
]

const router = createRouter(routes, '#router-outlet')
</code></pre>
<h2>Redirects</h2>
<p>You can redirect from a route by returning a redirect object from the action function:</p>
<pre><code class="language-js">const routes = [
  {
    path: '/redirect',
    action () {
      return { redirect: '/target' } // &lt;== request a redirect
    }
  },
  {
    path: '/admin',
    action(context) {
      if (!context.user) {
        return { redirect: '/login' }
      }
      return 'admin-page'
    }
  }
]
</code></pre>
<p>You can also use the <code>resolveRoute</code> option to redirect a route:</p>
<pre><code class="language-js">{
  resolveRoute (context, params) {
    // do some logic here
    return { redirect: '/login' }
  }
}
</code></pre>
<h2>Outlet</h2>
<p>The router outlet acts as a placeholder that marks the spot where the router should display the components for that outlet.</p>
<pre><code class="language-html">&lt;div id=&quot;router-outlet&quot;&gt;&lt;/div&gt;
</code></pre>
<p>Given the routes above, when the browser URL for this application becomes <code>/one</code>, the router matches that URL to the route path <code>/one</code> and displays the <code>&lt;page-one&gt;</code> component as a sibling to the <code>&lt;div id=&quot;router-outlet&quot;&gt;</code>.</p>
<h3>Named outlets</h3>
<p>Views can contain child outlets allowing components to be composed in the view dynamically based on route.</p>
<pre><code class="language-html">&lt;div id=&quot;outlet-sidebar&quot;&gt;&lt;/div&gt;
</code></pre>
<p>Routes can contain <code>outlets</code> that map named outlets to components:</p>
<pre><code class="language-js">const routes = [
  {
    path: '/hello/:username',
    action (context) {
      // this component contains a &lt;div id=&quot;outlet-sidebar&quot;&gt;&lt;/div&gt; outlet
      return `&lt;hello-page username=&quot;${context.params.username}&quot;&gt;&lt;/hello-page&gt;`
    },
    outlets: {
      '#outlet-sidebar': (context) =&gt; `&lt;sidebar-contents username=&quot;${context.params.username}&quot;&gt;&lt;/sidebar-contents&gt;`
    }
  }
]
</code></pre>
<p>The <code>outlets</code> object keys are CSS selectors that match an element in your view.
Each value must be a function that returns a string for a component or a <code>Promise</code> that resolves a string for a component.</p>
<p>Multiple outlets of the same name can exist and will be rendered with the same template. This is useful for displaying the same component in different locations - such as a mobile and desktop view.</p>
<pre><code class="language-js">const routes = [
  {
    path: '/hello/:username',
    action (context) {
      // this component contains a &lt;div class=&quot;outlet-sidebar&quot;&gt;&lt;/div&gt; outlet
      return `&lt;hello-page username=&quot;${context.params.username}&quot;&gt;&lt;/hello-page&gt;`
    },
    outlets: {
      '.outlet-sidebar': (context) =&gt; `&lt;sidebar-contents username=&quot;${context.params.username}&quot;&gt;&lt;/sidebar-contents&gt;`
    }
  }
]
</code></pre>
<h4><code>resolveRoute</code></h4>
<p>The <code>resolveRoute</code> option can return an object containing <code>template</code> and <code>outlets</code> properties:</p>
<pre><code class="language-js">{
  resolveRoute (context, params) {
    return {
      template: context.route.action(context, params), // call an existing route action for a template
      outlets: {
        '#bar': () =&gt; 'bar-contents'
      }
    }
  }
}
</code></pre>
<h2>Navigation</h2>
<p><code>router</code> instances can be used to programmatically change the current location using the following methods:</p>
<ul>
<li><code>router.push(path, [state])</code></li>
<li><code>router.replace(path, [state])</code></li>
<li><code>router.go(n)</code></li>
<li><code>router.goBack()</code></li>
<li><code>router.goForward()</code></li>
</ul>
<p>When using <code>push</code> or <code>replace</code> you can either specify both the URL path and state as separate arguments or include everything in a single location-like object as the first argument.</p>
<ol>
<li>A URL path <em>or</em></li>
<li>A location-like object with <code>{ pathname, search, hash, state }</code></li>
</ol>
<pre><code class="language-js">// Go to the /home route
router.push('/home')

// Go to the /home route with a query string
// and some state. Location state does not appear in the URL.
router.push('/home?the=query', { some: 'state' })

// If you prefer, use a single location-like object to specify both
// the URL and state. This is equivalent to the example above.
router.push({
  pathname: '/home',
  search: '?the=query',
  state: { some: 'state' }
})

// Go back to the previous history entry. The following
// two lines are synonymous.
router.go(-1)
router.goBack()
</code></pre>
<p>Please note; calling <code>router.push(path)</code> with a path that matches the current URL will be ignored.</p>
<h2>Location</h2>
<p>To retrieve the current location, use the <code>location</code> property:</p>
<pre><code class="language-js">router.location // retrieve the location
router.location.state // retrieve the location state
</code></pre>
<h2>Lazy load views</h2>
<p>To lazy load a view you can use the native ES6 import <code>import('/path/to/script.js')</code> within your route action:</p>
<pre><code class="language-js">{
  path: '',
  action: () =&gt; import('./views/home.js').then(() =&gt; 'home-page')
}
</code></pre>
<h2>Server-side routing</h2>
<p>If you are using the <code>history</code> routing mode, the router uses the <a href="https://developer.mozilla.org/en-US/docs/Web/API/History">HTML History API</a> to handle client-side routing. This breaks when the user refreshes a URL that isn't handled server-side.
To ensure the client can handle the URL, you need server-side logic to route to the client.</p>
<p>For example, when using NodeJS and Express:</p>
<pre><code class="language-js">app.get('*', function (req, res) {
  res.sendFile(__dirname + '/index.html')
})
</code></pre>
<h3>Full page reloads</h3>
<p>If the browser reloads to a route that is not at root level, for example; <code>/user/matt/tasks</code>, the browser will need to load resources relative to the root.
To ensure this happens, add a base tag to the head of your index page:</p>
<pre><code class="language-html">&lt;head&gt;
  &lt;base href=&quot;/&quot;&gt;
  &lt;!-- other head tags come after this --&gt;
&lt;/head&gt;
</code></pre>

    </article>
  </div>
</div>
<a href="#" class="cd-top text-replace"></a>

<script src="js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script type="module" src="js/scribbler.js"></script>
<script src="js/service-worker.js"></script>
</body>
</html>
